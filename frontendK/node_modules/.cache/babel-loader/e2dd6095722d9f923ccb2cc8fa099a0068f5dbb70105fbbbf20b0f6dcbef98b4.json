{"ast":null,"code":"// src/api.js\nexport function streamFrom(url, {\n  onLine,\n  onError,\n  onDone,\n  signal\n} = {}) {\n  // returns a promise that resolves when stream finished (or rejects on error)\n  return new Promise(async (resolve, reject) => {\n    try {\n      const res = await fetch(url, {\n        signal\n      });\n      if (!res.ok) throw new Error(`HTTP ${res.status}`);\n      if (!res.body) throw new Error(\"Streaming not supported by this browser/response\");\n      const reader = res.body.getReader();\n      const decoder = new TextDecoder(\"utf-8\");\n      let buf = \"\";\n      while (true) {\n        const {\n          done,\n          value\n        } = await reader.read();\n        if (done) break;\n        buf += decoder.decode(value, {\n          stream: true\n        });\n        const parts = buf.split(\"\\n\");\n        buf = parts.pop(); // last incomplete line stays in buf\n        for (const p of parts) {\n          // Trim only trailing \\r, keep other whitespace\n          const line = p.replace(/\\r$/, \"\");\n          if (line.length === 0) continue;\n          try {\n            onLine === null || onLine === void 0 ? void 0 : onLine(line);\n          } catch (cbErr) {\n            console.error(\"onLine callback error\", cbErr);\n          }\n        }\n      }\n\n      // leftover buffer\n      if (buf && buf.trim() !== \"\") {\n        onLine === null || onLine === void 0 ? void 0 : onLine(buf.replace(/\\r$/, \"\"));\n      }\n      onDone === null || onDone === void 0 ? void 0 : onDone();\n      resolve();\n    } catch (err) {\n      if (err.name === \"AbortError\") {\n        onError === null || onError === void 0 ? void 0 : onError(new Error(\"Aborted\"));\n        reject(err);\n        return;\n      }\n      onError === null || onError === void 0 ? void 0 : onError(err);\n      reject(err);\n    }\n  });\n}","map":{"version":3,"names":["streamFrom","url","onLine","onError","onDone","signal","Promise","resolve","reject","res","fetch","ok","Error","status","body","reader","getReader","decoder","TextDecoder","buf","done","value","read","decode","stream","parts","split","pop","p","line","replace","length","cbErr","console","error","trim","err","name"],"sources":["C:/Users/Taleem Hossain/Academics/IIT sem 3/Numerical Methods/Prime-Number-Assisgnment/k/frontend/src/api.js"],"sourcesContent":["// src/api.js\r\nexport function streamFrom(url, { onLine, onError, onDone, signal } = {}) {\r\n  // returns a promise that resolves when stream finished (or rejects on error)\r\n  return new Promise(async (resolve, reject) => {\r\n    try {\r\n      const res = await fetch(url, { signal });\r\n      if (!res.ok) throw new Error(`HTTP ${res.status}`);\r\n      if (!res.body) throw new Error(\"Streaming not supported by this browser/response\");\r\n\r\n      const reader = res.body.getReader();\r\n      const decoder = new TextDecoder(\"utf-8\");\r\n      let buf = \"\";\r\n\r\n      while (true) {\r\n        const { done, value } = await reader.read();\r\n        if (done) break;\r\n        buf += decoder.decode(value, { stream: true });\r\n        const parts = buf.split(\"\\n\");\r\n        buf = parts.pop(); // last incomplete line stays in buf\r\n        for (const p of parts) {\r\n          // Trim only trailing \\r, keep other whitespace\r\n          const line = p.replace(/\\r$/, \"\");\r\n          if (line.length === 0) continue;\r\n          try {\r\n            onLine?.(line);\r\n          } catch (cbErr) {\r\n            console.error(\"onLine callback error\", cbErr);\r\n          }\r\n        }\r\n      }\r\n\r\n      // leftover buffer\r\n      if (buf && buf.trim() !== \"\") {\r\n        onLine?.(buf.replace(/\\r$/, \"\"));\r\n      }\r\n\r\n      onDone?.();\r\n      resolve();\r\n    } catch (err) {\r\n      if (err.name === \"AbortError\") {\r\n        onError?.(new Error(\"Aborted\"));\r\n        reject(err);\r\n        return;\r\n      }\r\n      onError?.(err);\r\n      reject(err);\r\n    }\r\n  });\r\n}\r\n"],"mappings":"AAAA;AACA,OAAO,SAASA,UAAUA,CAACC,GAAG,EAAE;EAAEC,MAAM;EAAEC,OAAO;EAAEC,MAAM;EAAEC;AAAO,CAAC,GAAG,CAAC,CAAC,EAAE;EACxE;EACA,OAAO,IAAIC,OAAO,CAAC,OAAOC,OAAO,EAAEC,MAAM,KAAK;IAC5C,IAAI;MACF,MAAMC,GAAG,GAAG,MAAMC,KAAK,CAACT,GAAG,EAAE;QAAEI;MAAO,CAAC,CAAC;MACxC,IAAI,CAACI,GAAG,CAACE,EAAE,EAAE,MAAM,IAAIC,KAAK,CAAC,QAAQH,GAAG,CAACI,MAAM,EAAE,CAAC;MAClD,IAAI,CAACJ,GAAG,CAACK,IAAI,EAAE,MAAM,IAAIF,KAAK,CAAC,kDAAkD,CAAC;MAElF,MAAMG,MAAM,GAAGN,GAAG,CAACK,IAAI,CAACE,SAAS,CAAC,CAAC;MACnC,MAAMC,OAAO,GAAG,IAAIC,WAAW,CAAC,OAAO,CAAC;MACxC,IAAIC,GAAG,GAAG,EAAE;MAEZ,OAAO,IAAI,EAAE;QACX,MAAM;UAAEC,IAAI;UAAEC;QAAM,CAAC,GAAG,MAAMN,MAAM,CAACO,IAAI,CAAC,CAAC;QAC3C,IAAIF,IAAI,EAAE;QACVD,GAAG,IAAIF,OAAO,CAACM,MAAM,CAACF,KAAK,EAAE;UAAEG,MAAM,EAAE;QAAK,CAAC,CAAC;QAC9C,MAAMC,KAAK,GAAGN,GAAG,CAACO,KAAK,CAAC,IAAI,CAAC;QAC7BP,GAAG,GAAGM,KAAK,CAACE,GAAG,CAAC,CAAC,CAAC,CAAC;QACnB,KAAK,MAAMC,CAAC,IAAIH,KAAK,EAAE;UACrB;UACA,MAAMI,IAAI,GAAGD,CAAC,CAACE,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;UACjC,IAAID,IAAI,CAACE,MAAM,KAAK,CAAC,EAAE;UACvB,IAAI;YACF7B,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAG2B,IAAI,CAAC;UAChB,CAAC,CAAC,OAAOG,KAAK,EAAE;YACdC,OAAO,CAACC,KAAK,CAAC,uBAAuB,EAAEF,KAAK,CAAC;UAC/C;QACF;MACF;;MAEA;MACA,IAAIb,GAAG,IAAIA,GAAG,CAACgB,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;QAC5BjC,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAGiB,GAAG,CAACW,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;MAClC;MAEA1B,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAG,CAAC;MACVG,OAAO,CAAC,CAAC;IACX,CAAC,CAAC,OAAO6B,GAAG,EAAE;MACZ,IAAIA,GAAG,CAACC,IAAI,KAAK,YAAY,EAAE;QAC7BlC,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAG,IAAIS,KAAK,CAAC,SAAS,CAAC,CAAC;QAC/BJ,MAAM,CAAC4B,GAAG,CAAC;QACX;MACF;MACAjC,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAGiC,GAAG,CAAC;MACd5B,MAAM,CAAC4B,GAAG,CAAC;IACb;EACF,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}