{"ast":null,"code":"export const questionsData = {\n  1: {\n    title: \"Pattern Prime Numbers\",\n    description: \"A prime number is 12345678910987654321. Here n is 10. Find the next number that follows this pattern. That number n lies between 1000 and 3000. This was discovered by an Indian.\",\n    inputs: [{\n      label: \"Min n value\",\n      name: \"minN\",\n      type: \"number\",\n      placeholder: \"1000\"\n    }, {\n      label: \"Max n value\",\n      name: \"maxN\",\n      type: \"number\",\n      placeholder: \"3000\"\n    }],\n    hint: \"This problem involves creating palindromic numbers by concatenating sequences: 1,2,3,...,n,...,3,2,1 and testing for primality.\",\n    algorithm: \"Generate pattern numbers by concatenating ascending and descending sequences, then check primality using efficient algorithms. The answer to assignment question is 2446\",\n    code: `\nimport random\nimport sys\nimport gmpy2\n\ndef small_prime_check(num, p_set):\n    x = int(num)\n    for p in p_set:\n        if x % p == 0 and x != p:\n            return False\n    return True\n\ndef MR_Primality_Check(num):\n    x = int(num)\n    k = 40\n    isPrime = True\n    for t in range(0, k):\n        div_done = False\n        a = random.SystemRandom().randrange(2, x)\n        power = x - 1\n        while power % 2 == 0:\n            power //= 2\n            if (pow(a, power, x) == x - 1):\n                div_done = True\n                break\n        if div_done:\n            continue\n        elif pow(a, power, x) == x - 1 or pow(a, power, x) == 1:\n            continue\n        else:\n            isPrime = False\n            break\n    return isPrime\n\nsmall_prime_set = {2}\nfor i in range(3, 101):\n    notPrime = False\n    for p in small_prime_set:\n        if (i % p == 0):\n            notPrime = True\n            break\n    if not notPrime:\n        small_prime_set.add(i)\n\nsys.set_int_max_str_digits(100000)\nn = int(input(\"Enter min n value: \"))\nm = int(input(\"Enter max n value: \"))\nprime_numbers_set = []\nfor i in range(n, m + 1):\n    num = \"\"\n    for x in range(1, i + 1):\n        num += str(x)\n    for x in range(1, i):\n        num += str(i - x)\n    print(f\"token no. {i - n +1} / {m-n+1}\")\n    if small_prime_check(num, small_prime_set) == False:\n        print(f\"for n = {i}, number is not prime\")\n        continue\n    if gmpy2.is_prime(int(num)) == True:\n        prime_numbers_set.append(i)\n        print(f\"{num} is prime number where n = {i}\")\n    else:\n        print(f\"for n = {i}, number is not prime\")\n\nfor p in prime_numbers_set:\n    print(f\"for n = {p}, there is a prime number\")`\n  },\n  2: {\n    title: \"Repunit Primes\",\n    description: \"11 is prime, 111 is not prime. We use the notation, 1(N) means N ones. For example, 1(7), we mean seven ones : 1111111. 1(N) is represented by (10^N-1)/9. If N is prime 1(N) might be prime. If N is not prime, 1(N) can not be prime. Thus we have to check only for N being prime. Determine the 5 primes between N=2 and N=1040.\",\n    inputs: [{\n      label: \"Min n value\",\n      name: \"minN\",\n      type: \"number\",\n      placeholder: \"2\"\n    }, {\n      label: \"Max n value\",\n      name: \"maxN\",\n      type: \"number\",\n      placeholder: \"1040\"\n    }, {\n      label: \"Exit after how many primes\",\n      name: \"exitCount\",\n      type: \"number\",\n      placeholder: \"5\"\n    }],\n    hint: \"Repunit numbers follow the pattern 1, 11, 111, 1111... and can be calculated using the formula (10^n-1)/9.\",\n    algorithm: \"Using the mathematical formula (10^n - 1) / 9 to generate repunit numbers efficiently, then apply primality testing.\",\n    code: `\nimport random\nimport sys\n\nsmall_prime_set = {2}\nfor i in range(3, 101):\n    notPrime = False\n    for p in small_prime_set:\n        if(i % p == 0):\n            notPrime = True\n            break\n    if not notPrime:\n        small_prime_set.add(i)\n\ndef small_prime_check(num, p_set):\n    x = int(num)\n    for p in p_set:\n        if x % p == 0 and x != p:\n            return False\n    return True\n    \ndef MR_Primality_Check(num):\n    x = int(num)\n    if x < 101:\n        if small_prime_check(num, small_prime_set):\n            return True\n        else:\n            return False\n    k = 40\n    isPrime = True\n    for t in range(0, k):\n        div_done = False\n        a = random.SystemRandom().randrange(2, x)\n        power = x - 1\n        while power % 2 == 0:\n            power //= 2\n            if(pow(a, power, x) == x - 1):\n                div_done = True\n                break\n        if div_done:\n            continue\n        elif pow(a, power, x) == x - 1 or pow(a, power, x) == 1:\n            continue\n        else:\n            isPrime = False\n            break\n    return isPrime\n\nsys.set_int_max_str_digits(100000)\nn = int(input(\"Enter min n value: \"))\nm = int(input(\"Enter max n value: \"))\npm = int(input(\"After how many prime should the program exit (if found): \"))\nprime_count = 0\nfor i in range(n, m+1):\n    if small_prime_check(i, small_prime_set) == False:\n        continue\n    if MR_Primality_Check(i) == False:\n        continue\n    if MR_Primality_Check(((10**i - 1) // 9)) == True:\n        prime_count += 1\n        print(f\"1({i}) = {((10**i - 1) // 9)} is a prime number\")\n        print(f\"Prime count so far = {prime_count}\")\n    if prime_count == pm:\n        break\n    `\n  },\n  3: {\n    title: \"Mersenne Primes\",\n    description: \"We are interested in Mersenne primes. A Mersenne prime is a prime number that is one less than a power of two. The largest Mersenne prime discovered was on Oct 12, 2024 when 2^p-1 where p=136,279,841. This has 41,024,320 digits. Find the two primes where p lies between 2201 and 2299. These primes were discovered in 1952.\",\n    inputs: [{\n      label: \"Min p value\",\n      name: \"minP\",\n      type: \"number\",\n      placeholder: \"2201\"\n    }, {\n      label: \"Max p value\",\n      name: \"maxP\",\n      type: \"number\",\n      placeholder: \"2299\"\n    }],\n    hint: \"Mersenne primes have the form 2^p - 1 where p itself must be prime. These are among the largest known primes.\",\n    algorithm: \"First verify that p is prime, then compute 2^p - 1 and test for primality using specialized algorithms.\",\n    code: `\nimport random\n\nsmall_prime_set = {2}\nfor i in range(3, 101):\n    notPrime = False\n    for p in small_prime_set:\n        if(i % p == 0):\n            notPrime = True\n            break\n    if not notPrime:\n        small_prime_set.add(i)\n\ndef small_prime_check(num, p_set):\n    x = int(num)\n    for p in p_set:\n        if x % p == 0 and x != p:\n            return False\n    return True\n    \ndef MR_Primality_Check(num):\n    x = int(num)\n    if x < 101:\n        if small_prime_check(num, small_prime_set):\n            return True\n        else:\n            return False\n    k = 40\n    isPrime = True\n    for t in range(0, k):\n        div_done = False\n        a = random.SystemRandom().randrange(2, x)\n        power = x - 1\n        while power % 2 == 0:\n            power //= 2\n            if(pow(a, power, x) == x - 1):\n                div_done = True\n                break\n        if div_done:\n            continue\n        elif pow(a, power, x) == x - 1 or pow(a, power, x) == 1:\n            continue\n        else:\n            isPrime = False\n            break\n    return isPrime\n\nn = int(input(\"Enter min p value: \"))\nm = int(input(\"Enter max p value: \"))\nprime_count = 0\nfor i in range(n, m+1):\n    x = 2**i - 1\n    if small_prime_check(x, small_prime_set) == False:\n        continue\n    if MR_Primality_Check(x) == True:\n        prime_count += 1\n        print(f\"2^{i} - 1 = {x} is a prime number\")\n        print(f\"Prime count so far = {prime_count}\")\n    `\n  },\n  4: {\n    title: \"Brocard's Conjecture\",\n    description: \"Brocard's conjecture is the conjecture (open problem) that there are at least four prime numbers between (p(n))2 and (p(n+1))^2, where p(n) is the nth prime number, for every n ≥ 2. Use the two prime numbers you obtained in #3 and determine at least four prime numbers between the squares of those numbers.\",\n    inputs: [{\n      label: \"Min p value\",\n      name: \"minP\",\n      type: \"number\",\n      placeholder: \"2201\"\n    }, {\n      label: \"Max p value\",\n      name: \"maxP\",\n      type: \"number\",\n      placeholder: \"2299\"\n    }],\n    hint: \"This conjecture involves finding consecutive primes and checking the number of primes between their squares.\",\n    algorithm: \"First run question 3 to get the Mersenne primes. Find consecutive primes for each prime found in #3, compute their squares, then count primes in the interval between consecutive prime squares.\",\n    code: `\nimport random\nimport gmpy2\n\nsmall_prime_set = {2}\nfor i in range(3, 101):\n    notPrime = False\n    for p in small_prime_set:\n        if(i % p == 0):\n            notPrime = True\n            break\n    if not notPrime:\n        small_prime_set.add(i)\n\ndef small_prime_check(num, p_set):\n    x = int(num)\n    for p in p_set:\n        if x % p == 0 and x != p:\n            return False\n    return True\n    \ndef MR_Primality_Check(num):\n    x = int(num)\n    if x < 101:\n        if small_prime_check(num, small_prime_set):\n            return True\n        else:\n            return False\n    k = 40\n    isPrime = True\n    for t in range(0, k):\n        div_done = False\n        a = random.SystemRandom().randrange(2, x)\n        power = x - 1\n        while power % 2 == 0:\n            power //= 2\n            if(pow(a, power, x) == x - 1):\n                div_done = True\n                break\n        if div_done:\n            continue\n        elif pow(a, power, x) == x - 1 or pow(a, power, x) == 1:\n            continue\n        else:\n            isPrime = False\n            break\n    return isPrime\n\nn = int(input(\"Enter min p value: \"))\nm = int(input(\"Enter max p value: \"))\nprimes = []\nfor i in range(n, m+1):\n    x = 2**i - 1\n    if small_prime_check(x, small_prime_set) == False:\n        continue\n    if gmpy2.is_prime(x) == True:\n        print(f\"2^{i} - 1 = {x} is a prime number\")\n        primes.append(x)\nfor p in primes:\n    q = p + 1\n    while True:\n        if small_prime_check(q, small_prime_set) == False:\n            q += 1\n            continue\n        if gmpy2.is_prime(q) == False:\n            q += 1\n            continue\n        else:\n            break\n    print(f\"two consecutive primes are {p} and {q}\")\n    print(f\"Their squares are {p**2} and {q**2} ... Have to find atleast 4 primes between them ...\")\n    prime_count = 0\n    for x in range(p**2, q**2):\n        if small_prime_check(x, small_prime_set) == False:\n            continue\n        if gmpy2.is_prime(x) == True:\n            prime_count += 1\n            print(f\"{x} is a prime number ... {prime_count} prime number(s) found so far\")\n        if prime_count >= 4:\n            print(f\"{prime_count} prime numbers found ... PROVED!!!\")\n            break\n    `\n  },\n  5: {\n    title: \"Palindromic Primes\",\n    description: \"Palindromic prime numbers are prime numbers that are also palindromes. The simpler ones are 11 and 122333221. More interesting ones are 1223334444555554444333221 and 12233355555333221. The largest found so far is 10^1888529 − 10^944264 − 1 which has 1,888,529 digits. Find a palindromic prime that has at least 50 digits.\",\n    inputs: [{\n      label: \"Minimum digits\",\n      name: \"minDigits\",\n      type: \"number\",\n      placeholder: \"50\"\n    }, {\n      label: \"Maximum digits\",\n      name: \"maxDigits\",\n      type: \"number\",\n      placeholder: \"51\"\n    }, {\n      label: \"Exit after how many primes\",\n      name: \"exitCount\",\n      type: \"number\",\n      placeholder: \"1\"\n    }],\n    hint: \"Generate palindromic numbers systematically by constructing the first half and mirroring it.\",\n    algorithm: \"Construct palindromes by generating the first half and creating the mirror image, then test for primality.\",\n    code: `\nimport random\n\ndef small_prime_check(num, p_set):\n    x = int(num)\n    for p in p_set:\n        if x % p == 0 and x != p:\n            return False\n    return True\n    \ndef MR_Primality_Check(num):\n    x = int(num)\n    k = 40\n    isPrime = True\n    for t in range(0, k):\n        div_done = False\n        a = random.SystemRandom().randrange(2, x)\n        power = x - 1\n        while power % 2 == 0:\n            power //= 2\n            if(pow(a, power, x) == x - 1):\n                div_done = True\n                break\n        if div_done:\n            continue\n        elif pow(a, power, x) == x - 1 or pow(a, power, x) == 1:\n            continue\n        else:\n            isPrime = False\n            break\n    return isPrime\n        \ndef increment(half):\n    x = int(half)\n    x = x+1\n    return str(x)\n\nsmall_prime_set = {2}\nfor i in range(3, 101):\n    notPrime = False\n    for p in small_prime_set:\n        if(i % p == 0):\n            notPrime = True\n            break\n    if not notPrime:\n        small_prime_set.add(i)\n        \nn = int(input(\"Enter minimum digits: \"))\nm = int(input(\"Enter maximum digits: \"))\npm = int(input(\"After how many prime should the program exit (if found): \"))\nprime_count = 0\nif(n % 2 == 0):\n    n += 1\nhalf = \"1\"\nfor i in range(1, n // 2):\n    half += \"0\"\nfound = False\nwhile True:\n    for x in range(0, 10):\n        palindrome = half + str(x) + half[::-1]\n        if not small_prime_check(palindrome, small_prime_set):\n            continue\n        if MR_Primality_Check(palindrome):\n            prime_count += 1\n            print(f\"{palindrome} is a prime number and it has {len(palindrome)} digits\")\n            print(f\"Prime count so far = {prime_count}\")\n        if prime_count == pm:\n            break\n    if prime_count == pm:\n        break\n    half = increment(half)\n    if 2 * len(half) + 1 > m:\n        break\n    `\n  },\n  6: {\n    title: \"Perfect Numbers\",\n    description: \"A perfect number is a positive integer that is equal to the sum of its positive proper divisors, that is, divisors excluding the number itself. For instance, 6 has proper divisors 1, 2 and 3, and 1 + 2 + 3 = 6, so 6 is a perfect number. The next perfect number is 28, since 1 + 2 + 4 + 7 + 14 = 28. Euclid proved that if 2^p- 1 is prime, then 2^(p-1)*(2^p- 1) is a perfect number and then Euler proved that all even perfect numbers followed this form. The existence of odd perfect numbers is an open problem and it can be shown if such a number exists it should be > 10^1500.. Using the primes in #3, prove that the above expression yields a perfect number.\",\n    inputs: [{\n      label: \"Min p value\",\n      name: \"minP\",\n      type: \"number\",\n      placeholder: \"2201\"\n    }, {\n      label: \"Max p value\",\n      name: \"maxP\",\n      type: \"number\",\n      placeholder: \"2299\"\n    }],\n    hint: \"Perfect numbers are closely related to Mersenne primes. If 2^p - 1 is prime, then 2^(p-1) * (2^p - 1) is perfect.\",\n    algorithm: \"Find Mersenne primes 2^p - 1, then compute the corresponding perfect number using Euclid's formula.\",\n    code: `\nimport random\n\nsmall_prime_set = {2}\nfor i in range(3, 101):\n    notPrime = False\n    for p in small_prime_set:\n        if(i % p == 0):\n            notPrime = True\n            break\n    if not notPrime:\n        small_prime_set.add(i)\n\ndef small_prime_check(num, p_set):\n    x = int(num)\n    for p in p_set:\n        if x % p == 0 and x != p:\n            return False\n    return True\n    \ndef MR_Primality_Check(num):\n    x = int(num)\n    if x < 101:\n        if small_prime_check(num, small_prime_set):\n            return True\n        else:\n            return False\n    k = 40\n    isPrime = True\n    for t in range(0, k):\n        div_done = False\n        a = random.SystemRandom().randrange(2, x)\n        power = x - 1\n        while power % 2 == 0:\n            power //= 2\n            if(pow(a, power, x) == x - 1):\n                div_done = True\n                break\n        if div_done:\n            continue\n        elif pow(a, power, x) == x - 1 or pow(a, power, x) == 1:\n            continue\n        else:\n            isPrime = False\n            break\n    return isPrime\n\nn = int(input(\"Enter min p value: \"))\nm = int(input(\"Enter max p value: \"))\npowers = []\nfor i in range(n, m+1):\n    x = 2**i - 1\n    if x < 2:\n        continue\n    if small_prime_check(x, small_prime_set) == False:\n        continue\n    if MR_Primality_Check(x) == True:\n        print(f\"2^{i} - 1 = {x} is a prime number\")\n        powers.append(i)\nfor p in powers:\n    x = 2 ** (p - 1) * (2 ** p - 1)\n    print(f\"Checking p = {p} and number is (2^({p} - 1)) * (2^{p} - 1) = {2 ** (p - 1)} * {(2 ** p - 1)} = {x}\")\n    sum = 0\n    curr = 1\n    for t in range(0, p):\n        print(f\"{curr} is a divisor of {x} and {curr} < {x}\")\n        print(f\"=> {sum} + {curr} = {sum + curr}\")\n        sum += curr;\n        curr2 = curr * (2 ** p - 1)\n        if curr2 != x:\n            print(f\"{curr2} is a divisor of {x} and {curr2} < {x}\")\n            print(f\"=> {sum} + {curr2} = {sum + curr2}\")\n            sum += curr2;\n        curr *= 2\n    if (sum == x):\n        print(f\"[Proved]\")\n    else:\n        print(\"[Disproved]\")\n    `\n  },\n  7: {\n    title: \"Prime Conjectures Collection\",\n    description: \"These are some interesting problem in prime numbers, which are all open problems. Some are as follows and prove them for a number that has greater than 50 digits...\",\n    inputs: [{\n      label: \"Conjecture type (a-f)\",\n      name: \"type\",\n      type: \"select\",\n      options: [{\n        value: \"a\",\n        label: \"Wieferich Primes\"\n      }, {\n        value: \"b\",\n        label: \"Goldbach Conjecture\"\n      }, {\n        value: \"c\",\n        label: \"Weak Goldbach Problem\"\n      }, {\n        value: \"d\",\n        label: \"Prime Differences\"\n      }, {\n        value: \"e\",\n        label: \"Legendre's Conjecture\"\n      }, {\n        value: \"f\",\n        label: \"Oppermann's Conjecture\"\n      }]\n    }, {\n      label: \"Upper limit\",\n      name: \"limit\",\n      type: \"number\",\n      placeholder: \"1000\",\n      min: 1\n    }],\n    hint: \"These are famous unsolved or recently solved problems in number theory, each exploring different patterns in prime distribution.\",\n    algorithm: \"Each conjecture has its own specific algorithm for verification within given bounds.\",\n    subProblems: {\n      'a': {\n        title: \"Wieferich Primes\",\n        description: \"Find primes p where 2^(p-1) ≡ 1 (mod p^2)\"\n      },\n      'b': {\n        title: \"Goldbach Conjecture\",\n        description: \"Every even integer > 2 = sum of two primes\"\n      },\n      'c': {\n        title: \"Weak Goldbach Problem\",\n        description: \"Every odd number > 5 = sum of three primes\"\n      },\n      'd': {\n        title: \"Prime Differences\",\n        description: \"Every even positive integer = difference of two primes\"\n      },\n      'e': {\n        title: \"Legendre's Conjecture\",\n        description: \"Prime between n^2 and (n+1)^2\"\n      },\n      'f': {\n        title: \"Oppermann's Conjecture\",\n        description: \"Prime between n(n-1) and n^2, and between n^2 and n(n+1)\"\n      }\n    }\n  }\n};\nexport default questionsData;","map":{"version":3,"names":["questionsData","title","description","inputs","label","name","type","placeholder","hint","algorithm","code","options","value","min","subProblems"],"sources":["C:/Users/Taleem Hossain/Academics/IIT sem 3/Numerical Methods/Prime-Number-Assisgnment/frontendK/src/questionData.js"],"sourcesContent":["export const questionsData = {\r\n  1: {\r\n    title: \"Pattern Prime Numbers\",\r\n    description: \"A prime number is 12345678910987654321. Here n is 10. Find the next number that follows this pattern. That number n lies between 1000 and 3000. This was discovered by an Indian.\",\r\n    inputs: [\r\n      { label: \"Min n value\", name: \"minN\", type: \"number\", placeholder: \"1000\" },\r\n      { label: \"Max n value\", name: \"maxN\", type: \"number\", placeholder: \"3000\" }\r\n    ],\r\n    hint: \"This problem involves creating palindromic numbers by concatenating sequences: 1,2,3,...,n,...,3,2,1 and testing for primality.\",\r\n    algorithm: \"Generate pattern numbers by concatenating ascending and descending sequences, then check primality using efficient algorithms. The answer to assignment question is 2446\",\r\n    code: `\r\nimport random\r\nimport sys\r\nimport gmpy2\r\n\r\ndef small_prime_check(num, p_set):\r\n    x = int(num)\r\n    for p in p_set:\r\n        if x % p == 0 and x != p:\r\n            return False\r\n    return True\r\n\r\ndef MR_Primality_Check(num):\r\n    x = int(num)\r\n    k = 40\r\n    isPrime = True\r\n    for t in range(0, k):\r\n        div_done = False\r\n        a = random.SystemRandom().randrange(2, x)\r\n        power = x - 1\r\n        while power % 2 == 0:\r\n            power //= 2\r\n            if (pow(a, power, x) == x - 1):\r\n                div_done = True\r\n                break\r\n        if div_done:\r\n            continue\r\n        elif pow(a, power, x) == x - 1 or pow(a, power, x) == 1:\r\n            continue\r\n        else:\r\n            isPrime = False\r\n            break\r\n    return isPrime\r\n\r\nsmall_prime_set = {2}\r\nfor i in range(3, 101):\r\n    notPrime = False\r\n    for p in small_prime_set:\r\n        if (i % p == 0):\r\n            notPrime = True\r\n            break\r\n    if not notPrime:\r\n        small_prime_set.add(i)\r\n\r\nsys.set_int_max_str_digits(100000)\r\nn = int(input(\"Enter min n value: \"))\r\nm = int(input(\"Enter max n value: \"))\r\nprime_numbers_set = []\r\nfor i in range(n, m + 1):\r\n    num = \"\"\r\n    for x in range(1, i + 1):\r\n        num += str(x)\r\n    for x in range(1, i):\r\n        num += str(i - x)\r\n    print(f\"token no. {i - n +1} / {m-n+1}\")\r\n    if small_prime_check(num, small_prime_set) == False:\r\n        print(f\"for n = {i}, number is not prime\")\r\n        continue\r\n    if gmpy2.is_prime(int(num)) == True:\r\n        prime_numbers_set.append(i)\r\n        print(f\"{num} is prime number where n = {i}\")\r\n    else:\r\n        print(f\"for n = {i}, number is not prime\")\r\n\r\nfor p in prime_numbers_set:\r\n    print(f\"for n = {p}, there is a prime number\")`\r\n  },\r\n  2: {\r\n    title: \"Repunit Primes\",\r\n    description: \"11 is prime, 111 is not prime. We use the notation, 1(N) means N ones. For example, 1(7), we mean seven ones : 1111111. 1(N) is represented by (10^N-1)/9. If N is prime 1(N) might be prime. If N is not prime, 1(N) can not be prime. Thus we have to check only for N being prime. Determine the 5 primes between N=2 and N=1040.\",\r\n    inputs: [\r\n      { label: \"Min n value\", name: \"minN\", type: \"number\", placeholder: \"2\"},\r\n      { label: \"Max n value\", name: \"maxN\", type: \"number\", placeholder: \"1040\"},\r\n      { label: \"Exit after how many primes\", name: \"exitCount\", type: \"number\", placeholder: \"5\"}\r\n    ],\r\n    hint: \"Repunit numbers follow the pattern 1, 11, 111, 1111... and can be calculated using the formula (10^n-1)/9.\",\r\n    algorithm: \"Using the mathematical formula (10^n - 1) / 9 to generate repunit numbers efficiently, then apply primality testing.\",\r\n    code: `\r\nimport random\r\nimport sys\r\n\r\nsmall_prime_set = {2}\r\nfor i in range(3, 101):\r\n    notPrime = False\r\n    for p in small_prime_set:\r\n        if(i % p == 0):\r\n            notPrime = True\r\n            break\r\n    if not notPrime:\r\n        small_prime_set.add(i)\r\n\r\ndef small_prime_check(num, p_set):\r\n    x = int(num)\r\n    for p in p_set:\r\n        if x % p == 0 and x != p:\r\n            return False\r\n    return True\r\n    \r\ndef MR_Primality_Check(num):\r\n    x = int(num)\r\n    if x < 101:\r\n        if small_prime_check(num, small_prime_set):\r\n            return True\r\n        else:\r\n            return False\r\n    k = 40\r\n    isPrime = True\r\n    for t in range(0, k):\r\n        div_done = False\r\n        a = random.SystemRandom().randrange(2, x)\r\n        power = x - 1\r\n        while power % 2 == 0:\r\n            power //= 2\r\n            if(pow(a, power, x) == x - 1):\r\n                div_done = True\r\n                break\r\n        if div_done:\r\n            continue\r\n        elif pow(a, power, x) == x - 1 or pow(a, power, x) == 1:\r\n            continue\r\n        else:\r\n            isPrime = False\r\n            break\r\n    return isPrime\r\n\r\nsys.set_int_max_str_digits(100000)\r\nn = int(input(\"Enter min n value: \"))\r\nm = int(input(\"Enter max n value: \"))\r\npm = int(input(\"After how many prime should the program exit (if found): \"))\r\nprime_count = 0\r\nfor i in range(n, m+1):\r\n    if small_prime_check(i, small_prime_set) == False:\r\n        continue\r\n    if MR_Primality_Check(i) == False:\r\n        continue\r\n    if MR_Primality_Check(((10**i - 1) // 9)) == True:\r\n        prime_count += 1\r\n        print(f\"1({i}) = {((10**i - 1) // 9)} is a prime number\")\r\n        print(f\"Prime count so far = {prime_count}\")\r\n    if prime_count == pm:\r\n        break\r\n    `\r\n  },\r\n  3: {\r\n    title: \"Mersenne Primes\",\r\n    description: \"We are interested in Mersenne primes. A Mersenne prime is a prime number that is one less than a power of two. The largest Mersenne prime discovered was on Oct 12, 2024 when 2^p-1 where p=136,279,841. This has 41,024,320 digits. Find the two primes where p lies between 2201 and 2299. These primes were discovered in 1952.\",\r\n    inputs: [\r\n      { label: \"Min p value\", name: \"minP\", type: \"number\", placeholder: \"2201\"},\r\n      { label: \"Max p value\", name: \"maxP\", type: \"number\", placeholder: \"2299\"}\r\n    ],\r\n    hint: \"Mersenne primes have the form 2^p - 1 where p itself must be prime. These are among the largest known primes.\",\r\n    algorithm: \"First verify that p is prime, then compute 2^p - 1 and test for primality using specialized algorithms.\",\r\n    code: `\r\nimport random\r\n\r\nsmall_prime_set = {2}\r\nfor i in range(3, 101):\r\n    notPrime = False\r\n    for p in small_prime_set:\r\n        if(i % p == 0):\r\n            notPrime = True\r\n            break\r\n    if not notPrime:\r\n        small_prime_set.add(i)\r\n\r\ndef small_prime_check(num, p_set):\r\n    x = int(num)\r\n    for p in p_set:\r\n        if x % p == 0 and x != p:\r\n            return False\r\n    return True\r\n    \r\ndef MR_Primality_Check(num):\r\n    x = int(num)\r\n    if x < 101:\r\n        if small_prime_check(num, small_prime_set):\r\n            return True\r\n        else:\r\n            return False\r\n    k = 40\r\n    isPrime = True\r\n    for t in range(0, k):\r\n        div_done = False\r\n        a = random.SystemRandom().randrange(2, x)\r\n        power = x - 1\r\n        while power % 2 == 0:\r\n            power //= 2\r\n            if(pow(a, power, x) == x - 1):\r\n                div_done = True\r\n                break\r\n        if div_done:\r\n            continue\r\n        elif pow(a, power, x) == x - 1 or pow(a, power, x) == 1:\r\n            continue\r\n        else:\r\n            isPrime = False\r\n            break\r\n    return isPrime\r\n\r\nn = int(input(\"Enter min p value: \"))\r\nm = int(input(\"Enter max p value: \"))\r\nprime_count = 0\r\nfor i in range(n, m+1):\r\n    x = 2**i - 1\r\n    if small_prime_check(x, small_prime_set) == False:\r\n        continue\r\n    if MR_Primality_Check(x) == True:\r\n        prime_count += 1\r\n        print(f\"2^{i} - 1 = {x} is a prime number\")\r\n        print(f\"Prime count so far = {prime_count}\")\r\n    `\r\n  },\r\n  4: {\r\n    title: \"Brocard's Conjecture\",\r\n    description: \"Brocard's conjecture is the conjecture (open problem) that there are at least four prime numbers between (p(n))2 and (p(n+1))^2, where p(n) is the nth prime number, for every n ≥ 2. Use the two prime numbers you obtained in #3 and determine at least four prime numbers between the squares of those numbers.\",\r\n    inputs: [\r\n      { label: \"Min p value\", name: \"minP\", type: \"number\", placeholder: \"2201\"},\r\n      { label: \"Max p value\", name: \"maxP\", type: \"number\", placeholder: \"2299\"}\r\n    ],\r\n    hint: \"This conjecture involves finding consecutive primes and checking the number of primes between their squares.\",\r\n    algorithm: \"First run question 3 to get the Mersenne primes. Find consecutive primes for each prime found in #3, compute their squares, then count primes in the interval between consecutive prime squares.\",\r\n    code: `\r\nimport random\r\nimport gmpy2\r\n\r\nsmall_prime_set = {2}\r\nfor i in range(3, 101):\r\n    notPrime = False\r\n    for p in small_prime_set:\r\n        if(i % p == 0):\r\n            notPrime = True\r\n            break\r\n    if not notPrime:\r\n        small_prime_set.add(i)\r\n\r\ndef small_prime_check(num, p_set):\r\n    x = int(num)\r\n    for p in p_set:\r\n        if x % p == 0 and x != p:\r\n            return False\r\n    return True\r\n    \r\ndef MR_Primality_Check(num):\r\n    x = int(num)\r\n    if x < 101:\r\n        if small_prime_check(num, small_prime_set):\r\n            return True\r\n        else:\r\n            return False\r\n    k = 40\r\n    isPrime = True\r\n    for t in range(0, k):\r\n        div_done = False\r\n        a = random.SystemRandom().randrange(2, x)\r\n        power = x - 1\r\n        while power % 2 == 0:\r\n            power //= 2\r\n            if(pow(a, power, x) == x - 1):\r\n                div_done = True\r\n                break\r\n        if div_done:\r\n            continue\r\n        elif pow(a, power, x) == x - 1 or pow(a, power, x) == 1:\r\n            continue\r\n        else:\r\n            isPrime = False\r\n            break\r\n    return isPrime\r\n\r\nn = int(input(\"Enter min p value: \"))\r\nm = int(input(\"Enter max p value: \"))\r\nprimes = []\r\nfor i in range(n, m+1):\r\n    x = 2**i - 1\r\n    if small_prime_check(x, small_prime_set) == False:\r\n        continue\r\n    if gmpy2.is_prime(x) == True:\r\n        print(f\"2^{i} - 1 = {x} is a prime number\")\r\n        primes.append(x)\r\nfor p in primes:\r\n    q = p + 1\r\n    while True:\r\n        if small_prime_check(q, small_prime_set) == False:\r\n            q += 1\r\n            continue\r\n        if gmpy2.is_prime(q) == False:\r\n            q += 1\r\n            continue\r\n        else:\r\n            break\r\n    print(f\"two consecutive primes are {p} and {q}\")\r\n    print(f\"Their squares are {p**2} and {q**2} ... Have to find atleast 4 primes between them ...\")\r\n    prime_count = 0\r\n    for x in range(p**2, q**2):\r\n        if small_prime_check(x, small_prime_set) == False:\r\n            continue\r\n        if gmpy2.is_prime(x) == True:\r\n            prime_count += 1\r\n            print(f\"{x} is a prime number ... {prime_count} prime number(s) found so far\")\r\n        if prime_count >= 4:\r\n            print(f\"{prime_count} prime numbers found ... PROVED!!!\")\r\n            break\r\n    `\r\n  },\r\n  5: {\r\n    title: \"Palindromic Primes\",\r\n    description: \"Palindromic prime numbers are prime numbers that are also palindromes. The simpler ones are 11 and 122333221. More interesting ones are 1223334444555554444333221 and 12233355555333221. The largest found so far is 10^1888529 − 10^944264 − 1 which has 1,888,529 digits. Find a palindromic prime that has at least 50 digits.\",\r\n    inputs: [\r\n      { label: \"Minimum digits\", name: \"minDigits\", type: \"number\", placeholder: \"50\"},\r\n      { label: \"Maximum digits\", name: \"maxDigits\", type: \"number\", placeholder: \"51\"},\r\n      { label: \"Exit after how many primes\", name: \"exitCount\", type: \"number\", placeholder: \"1\"}\r\n    ],\r\n    hint: \"Generate palindromic numbers systematically by constructing the first half and mirroring it.\",\r\n    algorithm: \"Construct palindromes by generating the first half and creating the mirror image, then test for primality.\",\r\n    code: `\r\nimport random\r\n\r\ndef small_prime_check(num, p_set):\r\n    x = int(num)\r\n    for p in p_set:\r\n        if x % p == 0 and x != p:\r\n            return False\r\n    return True\r\n    \r\ndef MR_Primality_Check(num):\r\n    x = int(num)\r\n    k = 40\r\n    isPrime = True\r\n    for t in range(0, k):\r\n        div_done = False\r\n        a = random.SystemRandom().randrange(2, x)\r\n        power = x - 1\r\n        while power % 2 == 0:\r\n            power //= 2\r\n            if(pow(a, power, x) == x - 1):\r\n                div_done = True\r\n                break\r\n        if div_done:\r\n            continue\r\n        elif pow(a, power, x) == x - 1 or pow(a, power, x) == 1:\r\n            continue\r\n        else:\r\n            isPrime = False\r\n            break\r\n    return isPrime\r\n        \r\ndef increment(half):\r\n    x = int(half)\r\n    x = x+1\r\n    return str(x)\r\n\r\nsmall_prime_set = {2}\r\nfor i in range(3, 101):\r\n    notPrime = False\r\n    for p in small_prime_set:\r\n        if(i % p == 0):\r\n            notPrime = True\r\n            break\r\n    if not notPrime:\r\n        small_prime_set.add(i)\r\n        \r\nn = int(input(\"Enter minimum digits: \"))\r\nm = int(input(\"Enter maximum digits: \"))\r\npm = int(input(\"After how many prime should the program exit (if found): \"))\r\nprime_count = 0\r\nif(n % 2 == 0):\r\n    n += 1\r\nhalf = \"1\"\r\nfor i in range(1, n // 2):\r\n    half += \"0\"\r\nfound = False\r\nwhile True:\r\n    for x in range(0, 10):\r\n        palindrome = half + str(x) + half[::-1]\r\n        if not small_prime_check(palindrome, small_prime_set):\r\n            continue\r\n        if MR_Primality_Check(palindrome):\r\n            prime_count += 1\r\n            print(f\"{palindrome} is a prime number and it has {len(palindrome)} digits\")\r\n            print(f\"Prime count so far = {prime_count}\")\r\n        if prime_count == pm:\r\n            break\r\n    if prime_count == pm:\r\n        break\r\n    half = increment(half)\r\n    if 2 * len(half) + 1 > m:\r\n        break\r\n    `\r\n  },\r\n  6: {\r\n    title: \"Perfect Numbers\",\r\n    description: \"A perfect number is a positive integer that is equal to the sum of its positive proper divisors, that is, divisors excluding the number itself. For instance, 6 has proper divisors 1, 2 and 3, and 1 + 2 + 3 = 6, so 6 is a perfect number. The next perfect number is 28, since 1 + 2 + 4 + 7 + 14 = 28. Euclid proved that if 2^p- 1 is prime, then 2^(p-1)*(2^p- 1) is a perfect number and then Euler proved that all even perfect numbers followed this form. The existence of odd perfect numbers is an open problem and it can be shown if such a number exists it should be > 10^1500.. Using the primes in #3, prove that the above expression yields a perfect number.\",\r\n    inputs: [\r\n      { label: \"Min p value\", name: \"minP\", type: \"number\", placeholder: \"2201\"},\r\n      { label: \"Max p value\", name: \"maxP\", type: \"number\", placeholder: \"2299\"}\r\n    ],\r\n    hint: \"Perfect numbers are closely related to Mersenne primes. If 2^p - 1 is prime, then 2^(p-1) * (2^p - 1) is perfect.\",\r\n    algorithm: \"Find Mersenne primes 2^p - 1, then compute the corresponding perfect number using Euclid's formula.\",\r\n    code: `\r\nimport random\r\n\r\nsmall_prime_set = {2}\r\nfor i in range(3, 101):\r\n    notPrime = False\r\n    for p in small_prime_set:\r\n        if(i % p == 0):\r\n            notPrime = True\r\n            break\r\n    if not notPrime:\r\n        small_prime_set.add(i)\r\n\r\ndef small_prime_check(num, p_set):\r\n    x = int(num)\r\n    for p in p_set:\r\n        if x % p == 0 and x != p:\r\n            return False\r\n    return True\r\n    \r\ndef MR_Primality_Check(num):\r\n    x = int(num)\r\n    if x < 101:\r\n        if small_prime_check(num, small_prime_set):\r\n            return True\r\n        else:\r\n            return False\r\n    k = 40\r\n    isPrime = True\r\n    for t in range(0, k):\r\n        div_done = False\r\n        a = random.SystemRandom().randrange(2, x)\r\n        power = x - 1\r\n        while power % 2 == 0:\r\n            power //= 2\r\n            if(pow(a, power, x) == x - 1):\r\n                div_done = True\r\n                break\r\n        if div_done:\r\n            continue\r\n        elif pow(a, power, x) == x - 1 or pow(a, power, x) == 1:\r\n            continue\r\n        else:\r\n            isPrime = False\r\n            break\r\n    return isPrime\r\n\r\nn = int(input(\"Enter min p value: \"))\r\nm = int(input(\"Enter max p value: \"))\r\npowers = []\r\nfor i in range(n, m+1):\r\n    x = 2**i - 1\r\n    if x < 2:\r\n        continue\r\n    if small_prime_check(x, small_prime_set) == False:\r\n        continue\r\n    if MR_Primality_Check(x) == True:\r\n        print(f\"2^{i} - 1 = {x} is a prime number\")\r\n        powers.append(i)\r\nfor p in powers:\r\n    x = 2 ** (p - 1) * (2 ** p - 1)\r\n    print(f\"Checking p = {p} and number is (2^({p} - 1)) * (2^{p} - 1) = {2 ** (p - 1)} * {(2 ** p - 1)} = {x}\")\r\n    sum = 0\r\n    curr = 1\r\n    for t in range(0, p):\r\n        print(f\"{curr} is a divisor of {x} and {curr} < {x}\")\r\n        print(f\"=> {sum} + {curr} = {sum + curr}\")\r\n        sum += curr;\r\n        curr2 = curr * (2 ** p - 1)\r\n        if curr2 != x:\r\n            print(f\"{curr2} is a divisor of {x} and {curr2} < {x}\")\r\n            print(f\"=> {sum} + {curr2} = {sum + curr2}\")\r\n            sum += curr2;\r\n        curr *= 2\r\n    if (sum == x):\r\n        print(f\"[Proved]\")\r\n    else:\r\n        print(\"[Disproved]\")\r\n    `\r\n  },\r\n  7: {\r\n    title: \"Prime Conjectures Collection\",\r\n    description: \"These are some interesting problem in prime numbers, which are all open problems. Some are as follows and prove them for a number that has greater than 50 digits...\",\r\n    inputs: [\r\n      {\r\n        label: \"Conjecture type (a-f)\", name: \"type\", type: \"select\",\r\n        options: [\r\n          { value: \"a\", label: \"Wieferich Primes\" },\r\n          { value: \"b\", label: \"Goldbach Conjecture\" },\r\n          { value: \"c\", label: \"Weak Goldbach Problem\" },\r\n          { value: \"d\", label: \"Prime Differences\" },\r\n          { value: \"e\", label: \"Legendre's Conjecture\" },\r\n          { value: \"f\", label: \"Oppermann's Conjecture\" }\r\n        ]\r\n      },\r\n      { label: \"Upper limit\", name: \"limit\", type: \"number\", placeholder: \"1000\", min: 1 }\r\n    ],\r\n    hint: \"These are famous unsolved or recently solved problems in number theory, each exploring different patterns in prime distribution.\",\r\n    algorithm: \"Each conjecture has its own specific algorithm for verification within given bounds.\",\r\n    subProblems: {\r\n      'a': {\r\n         title: \"Wieferich Primes\", \r\n         description: \"Find primes p where 2^(p-1) ≡ 1 (mod p^2)\" \r\n        },\r\n      'b': { \r\n        title: \"Goldbach Conjecture\", \r\n        description: \"Every even integer > 2 = sum of two primes\" \r\n      },\r\n      'c': { \r\n        title: \"Weak Goldbach Problem\", \r\n        description: \"Every odd number > 5 = sum of three primes\" \r\n      },\r\n      'd': { \r\n        title: \"Prime Differences\", \r\n        description: \"Every even positive integer = difference of two primes\" },\r\n      'e': { \r\n        title: \"Legendre's Conjecture\", \r\n        description: \"Prime between n^2 and (n+1)^2\" },\r\n      'f': { \r\n        title: \"Oppermann's Conjecture\", \r\n        description: \"Prime between n(n-1) and n^2, and between n^2 and n(n+1)\" }\r\n    }\r\n  }\r\n};\r\n\r\nexport default questionsData;"],"mappings":"AAAA,OAAO,MAAMA,aAAa,GAAG;EAC3B,CAAC,EAAE;IACDC,KAAK,EAAE,uBAAuB;IAC9BC,WAAW,EAAE,mLAAmL;IAChMC,MAAM,EAAE,CACN;MAAEC,KAAK,EAAE,aAAa;MAAEC,IAAI,EAAE,MAAM;MAAEC,IAAI,EAAE,QAAQ;MAAEC,WAAW,EAAE;IAAO,CAAC,EAC3E;MAAEH,KAAK,EAAE,aAAa;MAAEC,IAAI,EAAE,MAAM;MAAEC,IAAI,EAAE,QAAQ;MAAEC,WAAW,EAAE;IAAO,CAAC,CAC5E;IACDC,IAAI,EAAE,iIAAiI;IACvIC,SAAS,EAAE,0KAA0K;IACrLC,IAAI,EAAE;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,CAAC;EACD,CAAC,EAAE;IACDT,KAAK,EAAE,gBAAgB;IACvBC,WAAW,EAAE,sUAAsU;IACnVC,MAAM,EAAE,CACN;MAAEC,KAAK,EAAE,aAAa;MAAEC,IAAI,EAAE,MAAM;MAAEC,IAAI,EAAE,QAAQ;MAAEC,WAAW,EAAE;IAAG,CAAC,EACvE;MAAEH,KAAK,EAAE,aAAa;MAAEC,IAAI,EAAE,MAAM;MAAEC,IAAI,EAAE,QAAQ;MAAEC,WAAW,EAAE;IAAM,CAAC,EAC1E;MAAEH,KAAK,EAAE,4BAA4B;MAAEC,IAAI,EAAE,WAAW;MAAEC,IAAI,EAAE,QAAQ;MAAEC,WAAW,EAAE;IAAG,CAAC,CAC5F;IACDC,IAAI,EAAE,4GAA4G;IAClHC,SAAS,EAAE,sHAAsH;IACjIC,IAAI,EAAE;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,CAAC;EACD,CAAC,EAAE;IACDT,KAAK,EAAE,iBAAiB;IACxBC,WAAW,EAAE,oUAAoU;IACjVC,MAAM,EAAE,CACN;MAAEC,KAAK,EAAE,aAAa;MAAEC,IAAI,EAAE,MAAM;MAAEC,IAAI,EAAE,QAAQ;MAAEC,WAAW,EAAE;IAAM,CAAC,EAC1E;MAAEH,KAAK,EAAE,aAAa;MAAEC,IAAI,EAAE,MAAM;MAAEC,IAAI,EAAE,QAAQ;MAAEC,WAAW,EAAE;IAAM,CAAC,CAC3E;IACDC,IAAI,EAAE,+GAA+G;IACrHC,SAAS,EAAE,yGAAyG;IACpHC,IAAI,EAAE;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,CAAC;EACD,CAAC,EAAE;IACDT,KAAK,EAAE,sBAAsB;IAC7BC,WAAW,EAAE,oTAAoT;IACjUC,MAAM,EAAE,CACN;MAAEC,KAAK,EAAE,aAAa;MAAEC,IAAI,EAAE,MAAM;MAAEC,IAAI,EAAE,QAAQ;MAAEC,WAAW,EAAE;IAAM,CAAC,EAC1E;MAAEH,KAAK,EAAE,aAAa;MAAEC,IAAI,EAAE,MAAM;MAAEC,IAAI,EAAE,QAAQ;MAAEC,WAAW,EAAE;IAAM,CAAC,CAC3E;IACDC,IAAI,EAAE,8GAA8G;IACpHC,SAAS,EAAE,kMAAkM;IAC7MC,IAAI,EAAE;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,CAAC;EACD,CAAC,EAAE;IACDT,KAAK,EAAE,oBAAoB;IAC3BC,WAAW,EAAE,mUAAmU;IAChVC,MAAM,EAAE,CACN;MAAEC,KAAK,EAAE,gBAAgB;MAAEC,IAAI,EAAE,WAAW;MAAEC,IAAI,EAAE,QAAQ;MAAEC,WAAW,EAAE;IAAI,CAAC,EAChF;MAAEH,KAAK,EAAE,gBAAgB;MAAEC,IAAI,EAAE,WAAW;MAAEC,IAAI,EAAE,QAAQ;MAAEC,WAAW,EAAE;IAAI,CAAC,EAChF;MAAEH,KAAK,EAAE,4BAA4B;MAAEC,IAAI,EAAE,WAAW;MAAEC,IAAI,EAAE,QAAQ;MAAEC,WAAW,EAAE;IAAG,CAAC,CAC5F;IACDC,IAAI,EAAE,8FAA8F;IACpGC,SAAS,EAAE,4GAA4G;IACvHC,IAAI,EAAE;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,CAAC;EACD,CAAC,EAAE;IACDT,KAAK,EAAE,iBAAiB;IACxBC,WAAW,EAAE,mpBAAmpB;IAChqBC,MAAM,EAAE,CACN;MAAEC,KAAK,EAAE,aAAa;MAAEC,IAAI,EAAE,MAAM;MAAEC,IAAI,EAAE,QAAQ;MAAEC,WAAW,EAAE;IAAM,CAAC,EAC1E;MAAEH,KAAK,EAAE,aAAa;MAAEC,IAAI,EAAE,MAAM;MAAEC,IAAI,EAAE,QAAQ;MAAEC,WAAW,EAAE;IAAM,CAAC,CAC3E;IACDC,IAAI,EAAE,mHAAmH;IACzHC,SAAS,EAAE,qGAAqG;IAChHC,IAAI,EAAE;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,CAAC;EACD,CAAC,EAAE;IACDT,KAAK,EAAE,8BAA8B;IACrCC,WAAW,EAAE,sKAAsK;IACnLC,MAAM,EAAE,CACN;MACEC,KAAK,EAAE,uBAAuB;MAAEC,IAAI,EAAE,MAAM;MAAEC,IAAI,EAAE,QAAQ;MAC5DK,OAAO,EAAE,CACP;QAAEC,KAAK,EAAE,GAAG;QAAER,KAAK,EAAE;MAAmB,CAAC,EACzC;QAAEQ,KAAK,EAAE,GAAG;QAAER,KAAK,EAAE;MAAsB,CAAC,EAC5C;QAAEQ,KAAK,EAAE,GAAG;QAAER,KAAK,EAAE;MAAwB,CAAC,EAC9C;QAAEQ,KAAK,EAAE,GAAG;QAAER,KAAK,EAAE;MAAoB,CAAC,EAC1C;QAAEQ,KAAK,EAAE,GAAG;QAAER,KAAK,EAAE;MAAwB,CAAC,EAC9C;QAAEQ,KAAK,EAAE,GAAG;QAAER,KAAK,EAAE;MAAyB,CAAC;IAEnD,CAAC,EACD;MAAEA,KAAK,EAAE,aAAa;MAAEC,IAAI,EAAE,OAAO;MAAEC,IAAI,EAAE,QAAQ;MAAEC,WAAW,EAAE,MAAM;MAAEM,GAAG,EAAE;IAAE,CAAC,CACrF;IACDL,IAAI,EAAE,kIAAkI;IACxIC,SAAS,EAAE,sFAAsF;IACjGK,WAAW,EAAE;MACX,GAAG,EAAE;QACFb,KAAK,EAAE,kBAAkB;QACzBC,WAAW,EAAE;MACd,CAAC;MACH,GAAG,EAAE;QACHD,KAAK,EAAE,qBAAqB;QAC5BC,WAAW,EAAE;MACf,CAAC;MACD,GAAG,EAAE;QACHD,KAAK,EAAE,uBAAuB;QAC9BC,WAAW,EAAE;MACf,CAAC;MACD,GAAG,EAAE;QACHD,KAAK,EAAE,mBAAmB;QAC1BC,WAAW,EAAE;MAAyD,CAAC;MACzE,GAAG,EAAE;QACHD,KAAK,EAAE,uBAAuB;QAC9BC,WAAW,EAAE;MAAgC,CAAC;MAChD,GAAG,EAAE;QACHD,KAAK,EAAE,wBAAwB;QAC/BC,WAAW,EAAE;MAA2D;IAC5E;EACF;AACF,CAAC;AAED,eAAeF,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}